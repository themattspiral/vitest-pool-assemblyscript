/**
 * AssemblyScript Transform to wrap top-level test calls
 *
 * This transform automatically wraps top-level `test()` and `describe()` calls
 * in an exported `__run_tests()` function, solving AssemblyScript's compiler bugs
 * with top-level code initialization while maintaining clean developer experience.
 *
 * PROBLEM:
 * AssemblyScript has compiler bugs when using top-level code:
 * - Const-folding fails for complex expressions like `1 + 1 == 2`
 * - Dead code elimination removes globals that aren't directly used by exports
 * - Top-level initialization order is unreliable
 *
 * SOLUTION:
 * Transform top-level code via source text manipulation (simpler than AST manipulation).
 *
 * INPUT (what developers write):
 * ```typescript
 * test("my test", () => {
 *   assert(1 + 1 == 2);
 * });
 * ```
 *
 * OUTPUT (what gets compiled):
 * ```typescript
 * export function __run_tests(): void {
 *   test("my test", () => {
 *     assert(1 + 1 == 2);
 *   });
 * }
 * ```
 *
 * How this transform works:
 * - Hooks into `afterParse` lifecycle
 * - Only processes test files (*.as.test.ts, *.as.spec.ts)
 * - Wraps entire source in `export function __run_tests(): void { ... }`
 * - Keeps imports outside the function
 *
 * USAGE:
 * Add to AssemblyScript compiler flags:
 *   --transform ./src/transforms/top-level-wrapper.mjs
 *
 * @see https://www.assemblyscript.org/compiler.html#transforms
 */

import { Transform } from "assemblyscript/transform";

class TopLevelWrapperTransform extends Transform {
  /**
   * Called after parsing is complete.
   * We manipulate the source text directly which is simpler than AST manipulation.
   */
  afterParse(parser) {
    // Walk through all source files
    const sources = this.program.sources;
    sources.forEach(source => {
      // Only process test files (*.as.test.ts or *.as.spec.ts)
      if (this.isTestFile(source)) {
        this.wrapInRunTestsFunction(source);
      }
    });
  }

  /**
   * Check if a source file is a test file
   */
  isTestFile(source) {
    const path = source.normalizedPath;
    return (
      (path.endsWith('.as.test.ts') || path.endsWith('.as.spec.ts')) &&
      !path.startsWith('~lib/') // Don't process library files
    );
  }

  /**
   * Wrap the source code in an exported __run_tests() function
   * Uses text manipulation instead of AST reconstruction
   */
  wrapInRunTestsFunction(source) {
    const originalText = source.text;

    // Split source into import statements and rest
    const lines = originalText.split('\n');
    const importLines = [];
    const codeLines = [];

    let inImportSection = true;
    for (const line of lines) {
      const trimmed = line.trim();

      // Keep imports and comments at the top
      if (inImportSection && (
        trimmed.startsWith('import ') ||
        trimmed.startsWith('export ') ||
        trimmed.startsWith('//') ||
        trimmed.startsWith('/*') ||
        trimmed.startsWith('*') ||
        trimmed === ''
      )) {
        importLines.push(line);
      } else {
        inImportSection = false;
        codeLines.push(line);
      }
    }

    // If there's no code to wrap, nothing to do
    if (codeLines.length === 0 || codeLines.every(line => line.trim() === '')) {
      return;
    }

    // Build new source with wrapped code
    const newSource = [
      ...importLines,
      '',
      '// Auto-generated by top-level-wrapper transform',
      'export function __run_tests(): void {',
      ...codeLines.map(line => line ? '  ' + line : line), // Indent code
      '}',
      ''
    ].join('\n');

    // Replace source text
    source.text = newSource;
  }
}

export default TopLevelWrapperTransform;
