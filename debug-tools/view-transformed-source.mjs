#!/usr/bin/env node
/**
 * Debug script to view the transformed AssemblyScript source
 * Shows what code is actually generated by the transform
 */

import asc from 'assemblyscript/dist/asc.js';
import { readFile } from 'fs/promises';

const testFile = process.argv[2] || 'tests/math.as.test.ts';

console.log('Compiling:', testFile);
console.log('='.repeat(60));

let transformedSource = null;

const result = await asc.main([
  testFile,
  '--outFile', 'output.wasm',
  '--optimizeLevel', '0',
  '--runtime', 'stub',
  '--importMemory',
  '--debug',
  '--textFile', 'output.wat',  // Generate WAT text format
  '--transform', './src/transforms/top-level-wrapper.mjs',
], {
  stdout: { write: () => {} },
  stderr: { write: (msg) => console.error('STDERR:', msg) },
  writeFile: (name, contents) => {
    if (name.endsWith('.wat')) {
      transformedSource = contents;
    }
  },
});

if (result.error) {
  console.error('Compilation error:', result.error.message);
  process.exit(1);
}

// The WAT file shows the actual compiled output
// Let's look at the exports section
console.log('\nSearching WAT output for export declarations...\n');

const watText = Buffer.from(transformedSource).toString('utf-8');
const exportLines = watText.split('\n').filter(line => line.includes('export'));

console.log('Export declarations in WAT:');
exportLines.forEach(line => console.log(line.trim()));

// Also let's check if we can see any re-export patterns
console.log('\n' + '='.repeat(60));
console.log('Searching for framework function references...\n');

const frameworkFuncs = ['__get_test_count', '__get_test_name', '__run_test', '__run_all_tests'];
frameworkFuncs.forEach(funcName => {
  const count = (watText.match(new RegExp(funcName, 'g')) || []).length;
  console.log(`${funcName}: ${count} references`);
});
